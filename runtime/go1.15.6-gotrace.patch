diff -Nru go1156/src/internal/trace/parser.go go1156-gotrace/src/internal/trace/parser.go
--- go1156/src/internal/trace/parser.go 2021-01-01 16:21:42.000000000 -0600
+++ go1156-gotrace/src/internal/trace/parser.go 2021-01-01 16:21:42.000000000 -0600
@@ -1058,7 +1058,9 @@
 	EvUserTaskEnd       = 46 // end of task [timestamp, internal task id, stack]
 	EvUserRegion        = 47 // trace.WithRegion [timestamp, internal task id, mode(0:start, 1:end), stack, name string]
 	EvUserLog           = 48 // trace.Log [timestamp, internal id, key string id, stack, value string]
-	EvCount             = 49
+	EvGoSend            = 49 // goroutine chan send [timestamp, stack]
+	EvGoRecv            = 50 // goroutine chan recv [timestamp, stack]
+	EvCount             = 51
 )

 var EventDescriptions = [EvCount]struct {
@@ -1117,4 +1119,6 @@
 	EvUserTaskEnd:       {"UserTaskEnd", 1011, true, []string{"taskid"}, nil},
 	EvUserRegion:        {"UserRegion", 1011, true, []string{"taskid", "mode", "typeid"}, []string{"name"}},
 	EvUserLog:           {"UserLog", 1011, true, []string{"id", "keyid"}, []string{"category", "message"}},
+	EvGoSend:            {"GoSend", 1011, false, []string{"eid", "cid", "val"}, nil},
+	EvGoRecv:            {"GoRecv", 1011, false, []string{"eid", "cid", "val"}, nil},
 }
diff -Nru go1156/src/runtime/chan.go go1156-gotrace/src/runtime/chan.go
--- go1156/src/runtime/chan.go 2021-01-01 16:21:42.000000000 -0600
+++ go1156-gotrace/src/runtime/chan.go 2021-01-01 16:21:42.000000000 -0600
@@ -30,6 +30,7 @@
 )

 type hchan struct {
+	id       uint64         // channel id for using in send/recv events
 	qcount   uint           // total data in the queue
 	dataqsiz uint           // size of the circular queue
 	buf      unsafe.Pointer // points to an array of dataqsiz elements
@@ -55,6 +56,12 @@
 	last *sudog
 }

+// global evil counters for channel and send/recv event IDs
+var (
+	chID uint64 = 1
+	evID uint64 = 1
+)
+
 //go:linkname reflect_makechan reflect.makechan
 func reflect_makechan(t *chantype, size int) *hchan {
 	return makechan(t, size)
@@ -109,6 +116,8 @@
 	c.elemsize = uint16(elem.size)
 	c.elemtype = elem
 	c.dataqsiz = uint(size)
+	chID = atomic.Xadd64(&chID, 1)
+	c.id = chID
 	lockInit(&c.lock, lockRankHchan)

 	if debugChan {
@@ -205,6 +214,8 @@
 	}

 	if sg := c.recvq.dequeue(); sg != nil {
+		sg.cid = c.id
+
 		// Found a waiting receiver. We pass the value we want to send
 		// directly to the receiver, bypassing the channel buffer (if any).
 		send(c, sg, ep, func() { unlock(&c.lock) })
@@ -218,7 +229,11 @@
 			raceacquire(qp)
 			racerelease(qp)
 		}
-		typedmemove(c.elemtype, qp, ep)
+
+		evID = atomic.Xadd64(&evID, 1)
+		traceGoSend(evID, c.id, elem2int(ep))
+
+			typedmemmove(c.elemtype, qp, ep)
 		c.sendx++
 		if c.sendx == c.dataqsiz {
 			c.sendx = 0
@@ -249,6 +264,12 @@
 	mysg.c = c
 	gp.waiting = mysg
 	gp.param = nil
+
+	mysg.cid = c.id
+	evID = atomic.Xadd64(&evID, 1)
+	mysg.eventid = atomic.Load64(&evID)
+	traceGoSend(mysg.eventid, c.id, elem2int(ep))
+
 	c.sendq.enqueue(mysg)
 	// Signal to anyone trying to shrink our stack that we're about
 	// to park on a channel. The window between when this G's status
@@ -309,6 +330,11 @@
 			c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz
 		}
 	}
+
+	evID = atomic.Xadd64(&evID, 1)
+	sg.eventid = atomic.Load64(&evID)
+	traceGoSend(evID, c.id, elem2int(ep))
+
 	if sg.elem != nil {
 		sendDirect(c.elemtype, sg, ep)
 		sg.elem = nil
@@ -576,6 +602,8 @@
 	atomic.Store8(&gp.parkingOnChan, 1)
 	gopark(chanparkcommit, unsafe.Pointer(&c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2)

+	traceGoRecv(mysg.eventid, c.id, elem2int(ep))
+
 	// someone woke us up
 	if mysg != gp.waiting {
 		throw("G waiting list is corrupted")
@@ -614,6 +642,7 @@
 			// copy data from sender
 			recvDirect(c.elemtype, sg, ep)
 		}
+		traceGoRecv(sg.eventid, c.id, elem2int(ep))
 	} else {
 		// Queue is full. Take the item at the
 		// head of the queue. Make the sender enqueue
@@ -632,6 +661,7 @@
 		}
 		// copy data from sender to queue
 		typedmemmove(c.elemtype, qp, sg.elem)
+		traceGoRecv(sg.eventid, c.id, elem2int(ep))
 		c.recvx++
 		if c.recvx == c.dataqsiz {
 			c.recvx = 0
@@ -834,3 +864,10 @@
 	racereleaseg(sg.g, chanbuf(c, 0))
 	raceacquire(chanbuf(c, 0))
 }
+
+func elem2int(elem unsafe.Pointer) uint64 {
+	if elem == nil {
+		return 0
+	}
+	return uint64(*((*int)(elem)))
+}
diff -Nru go1156/src/runtime/runtime2.go go1156-gotrace/src/runtime/runtime2.go
--- go1156/src/runtime/runtime2.go 2021-01-01 16:21:42.000000000 -0600
+++ go1156-gotrace/src/runtime/runtime2.go 2021-01-01 16:21:42.000000000 -0600
@@ -370,6 +370,10 @@
	waitlink *sudog // g.waiting list or semaRoot
	waittail *sudog // semaRoot
	c        *hchan // channel
+
+	eventid uint64 // used for correlating send/recv
+	value   string // used for representing value to tracer
+	cid     uint64 // channel id
 }

 type libcall struct {
diff -Nru go1156/src/runtime/select.go go1156-gotrace/src/runtime/select.go
--- go1156/src/runtime/select.go 2021-01-01 16:21:42.000000000 -0600
+++ go1156-gotrace/src/runtime/select.go 2021-01-01 16:21:42.000000000 -0600
@@ -324,6 +324,7 @@
 			c.recvq.enqueue(sg)

 		case caseSend:
+			traceGoSend(sg.eventid, c.id, elem2int(sg.elem))
 			c.sendq.enqueue(sg)
 		}
 	}
@@ -377,6 +378,9 @@
 				c.sendq.dequeueSudoG(sglist)
 			} else {
 				c.recvq.dequeueSudoG(sglist)
+				if sg != nil {
+					traceGoRecv(sg.eventid, sg.cid, elem2int(k.elem))
+				}
 			}
 		}
 		sgnext = sglist.waitlink
diff -Nru go1156/src/runtime/trace.go go1156-gotrace/src/runtime/trace.go
--- go1156/src/runtime/trace.go 2021-01-01 16:21:42.000000000 -0600
+++ go1156-gotrace/src/runtime/trace.go 2021-01-01 16:21:42.000000000 -0600
@@ -68,7 +68,10 @@
 	traceEv = 46 // end of a task [timestamp, internal task id, stack]
 	traceEv = 47 // trace.WithRegion [timestamp, internal task id, mode(0:start, 1:end), stack, name string]
 	traceEv = 48 // trace.Log [timestamp, internal task id, key string id, stack, value string]
-	traceEv = 49
+	traceEv = 49 // goroutine on chan send [timestamp, stack]
+	traceEv = 50 // goroutine on chan recv [timestamp, stack]
+	traceEv = 51
+
 	// Byte is used but only 6 bits are available for event type.
 	// The remaining 2 bits are used to specify the number of arguments.
 	// That means, the max event type value is 63.
@@ -1228,3 +1231,11 @@

 	traceReleaseBuffer(pid)
 }
+
+func traceGoSend(eid, cid, val uint64) {
+	traceEvent(traceEvGoSend, -1, eid, cid, val)
+}
+
+func traceGoRecv(eid, cid, val uint64) {
+	traceEvent(traceEvGoRecv, -1, eid, cid, val)
+}
